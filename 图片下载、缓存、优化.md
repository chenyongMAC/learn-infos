## 图片下载、缓存、优化

#### SDWebImage
提供的功能:
提供UIImageView的一个分类，以支持网络图片的加载与缓存管理
一个异步的图片加载器
一个异步的内存+磁盘图片缓存
支持GIF图片
支持WebP图片
后台图片解压缩处理
确保同一个URL的图片不被下载多次（内部提供一个NSMutableSet，根据url生成了黑名单）
确保虚假的URL不会被反复加载
确保下载及缓存时，主线程不被阻塞

knowledge:
1.下载
以队列的方式，按照先进先出的顺序下载。这是默认的下载顺序
以栈的方式，按照后进先出的顺序下载。
图片下载的这些回调信息存储在SDWebImageDownloader类的URLCallbacks属性中，该属性是一个字典，key是图片的URL地址，value则是一个数组，包含每个图片的多组回调信息。由于我们允许多个图片同时下载，因此可能会有多个线程同时操作URLCallbacks属性。为了保证URLCallbacks操作(添加、删除)的线程安全性，SDWebImageDownloader将这些操作作为一个个任务放到barrierQueue队列中，并设置屏障来确保同一时间只有一个线程操作URLCallbacks属性。
下载的核心其实就是利用NSURLConnection对象来加载数据。每个图片的下载都由一个Operation操作来完成，并将这些操作放到一个操作队列中。这样可以实现图片的并发下载。

2.缓存
内存缓存的处理是使用NSCache对象来实现的。NSCache是一个类似于集合的容器。它存储key-value对，这一点类似于NSDictionary类。
磁盘缓存的处理则是使用NSFileManager对象来实现的。图片存储的位置是位于Cache文件夹。另外，SDImageCache还定义了一个串行队列，来异步存储图片。


question:
1、SDImageCache是怎么做数据管理的?
SDImageCache分两个部分，一个是内存层面的，一个是硬盘层面的。
内存层面的相当是个缓存器，以Key-Value的形式存储图片。当内存不够的时候会清除所有缓存图片。
用搜索文件系统的方式做管理，文件替换方式是以时间为单位，剔除时间大于一周的图片文件。
当SDWebImageManager向SDImageCache要资源时，先搜索内存层面的数据，如果有直接返回，没有的话去访问磁盘，将图片从磁盘读取出来，然后做Decoder，将图片对象放到内存层面做备份，再返回调用层。


2、为啥必须做Decoder?
由于UIImage的imageWithData函数是每次画图的时候才将Data解压成ARGB的图像，
所以在每次画图的时候，会有一个解压操作(在主线程)，这样效率很低，但是只有瞬时的内存需求。为了提高效率通过SDWebImageDecoder将包装在Data下的资源解压(在异步线程中自动解压图片)。这种做法是典型的空间换时间的做法。
如果遇到高清图，自动解压缩操作会导致内存暴增，需要禁用SDImageCache中的自动解压缩配置。


3.clear和clean的区别?
clear 先把之前的缓存文件夹删除掉,然后在新建一个文件夹
clean 先删除过期的文件,然后计算剩余缓存文件的大小(currrentSize)>maxSize,继续删除,按照它缓存文件创建的时间删除,直到(currrentSize)<=maxSize


4.怎么处理图片的名称?
对URL进行MD5加密

5.如何区分不同格式的图像
据图像数据第一个字节来判断的


6.网络图片显示大体步骤
下载图片
图片处理（裁剪，边框等)
写入磁盘
从磁盘读取数据到内核缓冲区
从内核缓冲区复制到用户空间(内存级别拷贝)
解压缩为位图（耗cpu较高）
如果位图数据不是字节对齐的，CoreAnimation会copy一份位图数据并进行字节对齐
CoreAnimation渲染解压缩过的位图

CoreAnimation为什么要copy？
为了性能，底层渲染图像时不是一个像素一个像素渲染，而是一块一块渲染，数据是一块块地取，就可能遇到这一块连续的内存数据里结尾的数据不是图像的内容，是内存里其他的数据，可能越界读取导致一些奇怪的东西混入，所以在渲染之前CoreAnimation要把数据拷贝一份进行处理，确保每一块都是图像数据，对于不足一块的数据置空。


## 优化思路
* 异步下载图片
* image解压缩放到子线程
* 使用缓存 (包括内存级别和磁盘级别)
* 存储解压缩后的图片，避免下次从磁盘加载的时候再次解压缩  
* 减少内存级别的拷贝 		
良好的接口（比如SDWebImage使用category）
Core Data vs 文件存储
图片预下载


优化方式实例:
1.tableView中的异步下载任务
当tableview滑动，imageView重设数据源（url）时，会cancel掉下载列表中所有的任务，然后开启一个新的下载任务。另一种方式是，imageView对象和图片的url相关联，在滑动时，不取消旧的下载任务，而是在下载任务完成回调时，进行url匹配，只有匹配成功的image会刷新imageView对象，而其他的image则只做缓存操作，而不刷新UI。

SDWebImage管理了一个全局下载队列（在DownloadManager中）,并发量设置为6.也就是说如果可见cell的数目是大于6的，就会有部分下载队列处于等待状态。而且，在添加下载任务到全局的下载队列中去的时候，SDWebImage默认是采取LIFO策略的


2.如何减少内存级别的拷贝？
FastImageCache采用了另一种读写文件的方法，就是用mmap把文件映射到用户空间里的虚拟内存，文件中的位置在虚拟内存中有了对应的地址，可以像操作内存一样操作这个文件，相当于已经把整个文件放入内存，但在真正使用到这些数据前却不会消耗物理内存，也不会有读写磁盘的操作，只有真正使用这些数据时，也就是图像准备渲染在屏幕上时，虚拟内存管理系统VMS才根据缺页加载的机制从磁盘加载对应的数据块到物理内存，再进行渲染。这样的文件读写文件方式少了数据从内核缓存到用户空间的拷贝，效率很高。

